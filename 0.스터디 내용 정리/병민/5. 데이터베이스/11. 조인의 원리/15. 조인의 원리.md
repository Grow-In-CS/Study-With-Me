# 조인의 원리

DBMS에서 쿼리를 작성하고 데이터를 사용하기 위해서 조인 연산을 실행하면, DBMS는 자체적으로 이러한 쿼리 조인 연산을 최적화하기 위해 옵티마이저를 작동시킨 이후에 DB 엔진에게 실행문을 보냅니다.

옵티마이저는 데이터베이스의 상태를 파악하고 어떤 조인 알고리즘을 사용하면 좋을지 어떤 인덱스를 사용하면 좋을지 자체적으로 판단하여 조인연산을 최적화합니다.

![옵티마이저](https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FQlDmC%2Fbtq7ULaKVn2%2FAAAAAAAAAAAAAAAAAAAAAGPPwvv5AY6f81SA7x0V1TQgdzwygbLU7_hMD3MRjBTL%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1759244399%26allow_ip%3D%26allow_referer%3D%26signature%3DpKu3ENMZJqVsGW2fmcINar9aFdU%253D)

## 중첩 루프 조인 (Nested Loop Join)

중첩 루프 조인은 선행 테이블의 처리 범위를 하나씩 엑세스하면서 그 값으로 후행 테이블을 조인하는 방식입니다.

일종의 2중 for문처럼 작동합니다. 따라서 실행 속도는 `선행 테이블 사이즈 x 후행 테이블 사이즈`가 됩니다. 

![nested loop join](https://blog.kakaocdn.net/dna/cVeENK/btrKWBaEfgK/AAAAAAAAAAAAAAAAAAAAAG5l2UKVxT37zNphHJTw_7SoBJuhmiMninpgjL095Zna/img.gif?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1759244399&allow_ip=&allow_referer=&signature=3ZmJHwOKn7P84GcYV9D16rRbSLA%3D)

### 중첩 루프 조인의 장점

- 적은 메모리 사용량
- 좁은 범위에서 성능이 좋음

### 중첩 루프 조인의 단점

- 데이터를 랜덤으로 엑세스하여 결과 집합이 많으면 속도가 느려짐
- join index가 없거나 조인 집합을 구성하는 검색 조건이 조인 범위를 줄이지 못할 경우 비효율적임

선행 테이블과 일치하는 값을 후행 테이블에서 찾아 조인하므로 후행 테이블의 연결고리가 중요합니다. 
즉, 후행 테이블에 인덱스가 있어야 테이블 전체를 탐색하지 않고 필요한 행에 대해서만 탐색하여 효율적입니다.

## 정렬 병합 조인 (Sort Merge Join)

정렬 병합 조인은 양쪽 테이블을 정렬 후 스캔하여 조인을 수행합니다. 
양쪽 테이블의 처리 범위를 각자 액세스하여 정렬한 결과를 차례로 스캔하면서 연결고리의 조건으로 머지하는 방식입니다. 
조인의 대상 범위가 넓어 랜덤 액세스를 줄이기 위한 경우 또는 연결고리에 마땅한 인덱스가 존재하지 않을 경우 사용합니다. 
중첩 반복 조인보다 훨씬 빨라지는 경우도 많으나 일반적으로는 사용 빈도가 적습니다.

![sort merge join](https://blog.kakaocdn.net/dna/VDbUK/btrKU780zKJ/AAAAAAAAAAAAAAAAAAAAAMszAHHbsTB-tOzDvL0-17RpinlT6aBr0ktFEdA7n66q/img.gif?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1759244399&allow_ip=&allow_referer=&signature=2D01ZsGf%2B%2FfMj5MbRhr5OJOQS28%3D)

각 키에 의해 정렬된 테이블을 선행/후행 개념 없이 병합하여 조인을 수행합니다.
선행 테이블, 후행 테이블의 크기는 성능과 관련이 없기 때문에 조인의 방향과는 무관합니다.
그러나 선행 테이블에는 메모리 사용량이 적은 중복 행이 존재하지 않는 테이블 사용을 권장합니다.
자신의 처리범위를 줄이기 위해 인덱스를 사용하는 경우를 제외하고, 스캔 방식으로 데이터를 읽기 때문에 랜덤 액세스로 부담이 되는 넓은 범위의 데이터를 처리할 때 이용합니다.

양 테이블은 모두 조인키에 의해 정렬되어 있어야 합니다. 
정렬할 데이터가 많아 모든 정렬 작업을 수행하기 어려운 경우에는 임시 영역을 사용하므로 성능이 떨어질 수 있습니다.

### 정렬 병합 조인의 장점

- 랜덤 액세스가 줄어 시스템 부하 감소
- 주로 스캔 방식으로 데이터를 읽기 때문에 랜덤 액세스로 부담이 되는 넓은 범위의 데이터를 처리할 때 효과적

### 정렬 병합 조인의 단점

- 정렬 시 메모리 사용량이 증가함
- 두 테이블의 크기 차이가 많이 나는 경우 비효율적임

## 해시 조인 (Hash Join)

해시 매치 조인은 두 테이블 중 작은 테이블로 해시 테이블 버킷(Hash Table Buckets)을 생성하고 큰 테이블로 Hash Function에 의한 탐색을 하면서 조인하는 방식입니다.
테이블의 인덱스는 사용되지 않기 때문에, 인덱스가 없는 테이블을 조인하려고 할 때 탁월한 성능을 보입니다.

![Hash Join](https://blog.kakaocdn.net/dna/mTrPF/btrK0M23XAz/AAAAAAAAAAAAAAAAAAAAALbJ0ieQv6nRodZtayLj7WEctBSrA1gkAYFeRuKWx-wq/img.gif?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1759244399&allow_ip=&allow_referer=&signature=DQqHd2EHyj8ZoPU860spCNzIBAk%3D)

이러한 해시 조인은 중첩루프 조인과 정렬병합 조인의 단점을 극복했습니다.

랜덤 엑세스가 있으나 중첩 반복 조인과는 달리 빠르고, 정렬의 부하가 많이 발생하는 정렬 병합 조인의 단점을 보완하기 위해 Hash Function을 이용합니다. 해싱 함수는 직접적인 연결을 담당하는 것이 아니라 연결될 대상을 모아두는 역할을 합니다.

두 테이블 중 크기가 작은 테이블을 기준으로 해시 테이블을 생성합니다. 해싱 함수의 시간 복잡도는 O(1)으로 속도가 빠르기 떄문에 대용량의 데이터를 처리할 때 사용합니다.
하지만 해시 충돌 및 해시 체인의 크기가 커지는 것을 방지하기 위해 중복되는 데이터가 적은 경우, 해시 테이블 버킷에 충분히 담길 수 있도록 선행 테이블의 데이터 양이 적은 경우에 사용하는 것이 좋습니다.

조인의 결과는 정렬하지 않은 상태로 출력됩니다. 특정 컬럼을 기준으로 정렬하고 싶다면 ORDER BY절을 이용해야 합니다.

### 해시 조인 장점

- 대량의 데이터를 조인할 때 사용
- 양쪽 테이블 모두 JOIN 컬럼에 인덱스가 없을 경우 사용 - 속도가 빠름

### 해시 조인 단점

- 해시 테이블 생성 시 많은 메모리를 사용하며 오버헤드가 발생할 수 있음.
- 소량의 데이터를 조인할 때 오히려 불필요한 I/O가 증가될 수 있음
- CBO에서만 가능하며, CPU 성능에 의존적

#### 비용기반 옵티마이저 (CBO, Cost-Based Optimizer)

CBO는 쿼리의 여러 가능한 실행계획(plan) 중에서 비용(cost) 을 추정해 가장 “싼” 계획을 선택하는 모듈입니다.
비용은 보통 I/O(디스크/버퍼 스캔), CPU(연산/정렬/해시), 메모리 사용 등을 수치화한 값입니다.
단순 규칙(rule-based)이 아니라 통계(Statistics)를 바탕으로 실질적인 비용을 계산하기 때문에 통계의 정확성이 매우 중요합니다.

요약하자면 아래와 같습니다.

- CBO는 통계 기반으로 계획을 선택하므로 정확한 통계와 적절한 인덱스/메모리 설정이 성능의 핵심입니다.
- 조인 알고리즘(Nested Loop / Sort-Merge / Hash)은 데이터 규모, 인덱스 유무, 메모리 제약, 분포 등에 따라 선택됩니다.

#### 공식기반 옵티마이저 (RBD, Rule-Based Optimizer)

공식기반 옵티마이저는 미리 정해진 공식에 의해 가장 빠른 실행 방법을 결정하는 것입니다.
우선순위가 빠른 검색방법을 선택하는것이 보다 성능을 향상 시킬수 있으며, 사용자는 이런점을 고려하여 빠른 우선 순위를 가진 SQL 문장을 작성하면 보다 더 빠른 성능을 보장할수 있습니다.

하지만 최근 db에서는 CBO가 대체적으로 자동적으로 적용되기 때문에 수동으로 설정을 통해 바꿀 수 있습니다.

## Reference

https://blog.kakaocdn.net/dna/cVeENK/btrKWBaEfgK/AAAAAAAAAAAAAAAAAAAAAG5l2UKVxT37zNphHJTw_7SoBJuhmiMninpgjL095Zna/img.gif?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1759244399&allow_ip=&allow_referer=&signature=3ZmJHwOKn7P84GcYV9D16rRbSLA%3D
https://zhiblog.tistory.com/33
https://m.blog.naver.com/kang_sok/60194747106