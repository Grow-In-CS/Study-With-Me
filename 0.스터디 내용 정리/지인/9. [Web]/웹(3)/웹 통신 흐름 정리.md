# 웹 통신 흐름 정리

웹 통신의 전체 흐름은 사용자가 브라우저에서 URL을 입력하고, 화면에 결과가 표시되기까지의 모든 과정을 의미합니다.

이 과정은 하드웨어(컴퓨터, 네트워크 장비), 네트워크 프로토콜(HTTP, TCP/IP), 소프트웨어(브라우저, 서버) 등이 복합적으로 작동하면서 이루어집니다.

<br/>

## 1. 사용자가 URL을 입력하거나 요청을 발생시킴

사용자가 브라우저 주소창에 `https://www.example.com`과 같은 주소를 입력하거나, 페이지 내의 링크를 클릭하면 **브라우저는 요청(Request)을 시작**합니다.

이때 브라우저는 입력된 주소를 분석하여 다음과 같은 구성 요소를 구분합니다.

- **프로토콜:** `https://` → 통신 방식(HTTP or HTTPS)
- **도메인 이름:** `www.example.com` → 접근할 서버의 주소
- **경로:** `/index.html` → 서버 내의 특정 자원 위치
- **쿼리 문자열:** `?id=123` → 추가적인 요청 정보

<br/>

## 2. DNS(Domain Name System) 조회

브라우저는 URL에 포함된 도메인(`www.example.com`)을 **IP 주소로 변환해야** 실제 서버에 접근할 수 있습니다.

이를 위해 로컬 캐시, ISP의 DNS 서버 또는 전 세계 분산된 DNS 서버에 질의하여 도메인에 대응하는 IP 주소를 찾아냅니다.

1. **브라우저 캐시 확인** → 이전에 방문한 사이트라면 캐시된 IP 사용
2. **OS 캐시 확인** → 시스템 레벨의 DNS 캐시 조회
3. **라우터 캐시 확인** → 공유기 등 로컬 네트워크 장비의 캐시
4. **DNS 서버 질의** → ISP(통신사)의 DNS 서버에 요청하여 IP 주소를 얻음

최종적으로 서버의 IP 주소를 획득하면 브라우저는 이제 그 IP로 요청을 보낼 준비를 마칩니다.

<br/>

## 3. TCP 연결 (3-way Handshake)

웹 클라이언트(브라우저)와 웹 서버 간 통신을 위해 TCP 3-way 핸드쉐이크 방식으로 네트워크 연결을 수립합니다.

TCP는 신뢰성 있는 통신을 보장하기 위해 연결을 설정하는 과정을 거칩니다.

1. **SYN:** 클라이언트(브라우저)가 서버에 연결 요청 신호(SYN) 전송
2. **SYN + ACK:** 서버가 연결 승인 신호(SYN + ACK) 응답
3. **ACK:** 클라이언트가 승인 확인(ACK)을 보냄

이 세 단계로 TCP 연결이 성립됩니다.

(HTTP/3에서는 UDP 기반의 QUIC 프로토콜을 사용하여 이 과정을 최적화)

<br/>

## 4. TLS 핸드셰이크 (HTTPS일 경우)

HTTPS는 **HTTP 위에서 TLS(SSL) 암호화**를 적용한 형태입니다.

따라서 TCP 연결 이후 **보안 연결 협상 과정**이 추가됩니다.

- 클라이언트가 서버의 인증서(Certificate)를 받아 유효성을 검증 (공인 인증서 기관 CA를 통해 확인)
- 암호화 키 교환을 수행 (대칭키 암호화를 위한 세션 키 생성)
- 이후 모든 통신은 암호화되어 송수신됨

<br/>

## 5. HTTP 요청 전송

연결이 완료되면 브라우저는 사용자의 요청에 맞는 **HTTP 요청(Request)** 메시지를 서버에 전송합니다.

이 요청은 다음과 같은 구조로 구성되며, TCP 프로토콜을 통해 인터넷을 거쳐 해당 서버의 IP 주소로 전송됩니다.

```yaml
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 ...
Accept: text/html
```

- **요청 라인:** 메서드(GET, POST 등), 경로, HTTP 버전
- **헤더:** 브라우저 정보, 인증 정보, 쿠키, 언어 설정 등
- **본문(Body):** 주로 POST 요청에서 폼 데이터나 JSON을 포함

<br/>

## 6. 서버 처리

서버는 요청을 수신한 후 내부 로직에 따라 응답을 생성합니다.

- 서버에 도착한 패킷은 OS의 프로토콜 스택에서 역캡슐화되어 HTTP 요청 메시지로 복원됩니다.
- 웹 서버 애플리케이션이 이 요청을 받아 처리하게 됩니다.

1. **요청 라우팅:** URL 경로에 따라 어떤 컨트롤러 또는 리소스를 호출할지 결정
2. **비즈니스 로직 실행:** 데이터베이스 조회, 연산, 인증 처리 등 수행
3. **응답 생성:** HTML, JSON, 이미지 등 필요한 형태로 응답 본문 작성

이후 서버는 **HTTP 응답(Response)**을 브라우저로 보냅니다.

<br/>

## 7. HTTP 응답 수신

서버는 요청받은 URL이나 데이터에 맞는 리소스(HTML, 이미지, API 데이터 등)를 조회하거나 연산 후 HTTP 응답 메시지를 만듭니다.

응답 메시지는 다음과 같이 구성됩니다.

```yaml
HTTP/1.1 200 OK
Content-Type: text/html; charset=UTF-8
Content-Length: 1024

<html>...</html>
```

- **상태 라인:** 상태 코드(200, 404, 500 등)와 상태 메시지
- **헤더:** 콘텐츠 타입, 쿠키 설정(Set-Cookie), 캐시 정책 등
- **본문:** 실제 콘텐츠 데이터

생성된 응답 메시지는 다시 TCP 프로토콜을 거쳐 클라이언트로 전송됩니다.

<br/>

## 8. 브라우저 렌더링 과정

브라우저는 받은 응답(HTML)을 해석하고 화면에 표시하기 위해 여러 단계를 수행합니다.

1. **HTML 파싱 → DOM 트리 생성**
2. **CSS 파싱 → CSSOM 트리 생성**
3. **JavaScript 실행 (DOM 조작, 비동기 요청 등)**
4. **렌더 트리(Render Tree) 생성 및 레이아웃 계산**
5. **페인팅(Painting) → 픽셀 렌더링**

이 과정에서 브라우저는 추가로 필요한 자원(JS, CSS, 이미지 등)을 **병렬 요청**하여 다시 같은 요청-응답 사이클을 반복합니다.

<br/>

## 9. 사용자가 보는 화면 완성

렌더링이 완료되면 사용자는 완성된 웹페이지를 볼 수 있습니다.

이후 스크롤, 클릭 등의 이벤트가 발생할 때마다 **추가적인 HTTP 요청(Ajax, Fetch API 등)** 이 비동기적으로 서버와 통신하며 페이지를 갱신합니다.

<br/>
<br/>

> 참고
>
> - https://velog.io/@woo0_hooo/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9B%B9-%ED%86%B5%EC%8B%A0%EC%9D%98-%ED%9D%90%EB%A6%84
> - https://woo0doo.tistory.com/11
