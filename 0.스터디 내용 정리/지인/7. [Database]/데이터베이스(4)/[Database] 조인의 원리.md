# 조인의 원리

다양한 상황에서 최적의 성능을 내기 위해, 적절한 JOIN 계획을 세워 동작을 수행합니다.

일반적으로 옵티마이저가 계획을 수립하지만, 항상 최적의 계획만을 고르는 것은 아닙니다.

그럴 경우, 수동으로 JOIN 계획을 지정해야 할 때가 있습니다.

조인 계획에는 세 가지 기법이 존재합니다.

<br/>

## 중첩 루프 조인 (Nested Loops Join)

NL JOIN이라고도 불리는 이 방식은 두 개 이상의 테이블에서 한 집합을 기준으로 상대 테이블의 행을 순차적으로 결합합니다.

이 방식은 조인할 데이터의 양이 적을 때 효율적입니다.

먼저 드라이빙 테이블에서 WHERE 조건을 충족하는 행을 찾습니다.

그런 다음 이 값들을 사용해 조인 대상 테이블을 반복적으로 검색하여 조인 조건을 만족하는 결과를 얻습니다.

<br/>

### **Driving Table 과 Driven Table**

JOIN 시 먼저 액세스되어 접근 경로를 주도하는 테이블을 Driving Table이라고 합니다.

나중에 액세스되는 테이블은 Driven Table입니다.

일반적으로 옵티마이저가 Driving/Driven Table을 결정합니다.

<br/>

### 이중 for문에 빗댄 작동 원리

동작 순서는 다음과 같은 이중 반복과 유사합니다.

바깥 반복이 Driving Table을 순회하고, 안쪽 반복이 Driven Table에서 일치 행을 찾습니다.

```jsx
for (i = 0; i < dept.length; i++) {
  // Driving table
  for (j = 0; j < emp.length; j++) {
    // Driven table
    // 조건이 맞으면 결합
  }
}
```

바깥쪽 반복을 줄이려면 Driving Table을 작게 만들고, 안쪽 탐색을 빠르게 하려면 Driven Table의 조인 컬럼에 인덱스를 둡니다.

NL JOIN의 튜닝 핵심이 이 두 줄 요약에 담겨 있습니다.

<br/>

### **NL Join 특징**

**1) 인덱스가 핵심입니다.**

조인 열에 인덱스가 없으면 **Driven 테이블**을 매번 Full Scan하게 되어 성능이 크게 저하됩니다.

NL JOIN은 **Driving 테이블**의 각 행을 기준으로 반복 접근하는 **랜덤 액세스 중심** 방식입니다.

성능 최적화를 위해 랜덤 액세스 범위를 최소화하도록 인덱스를 구성하는 것이 중요합니다.

인덱스가 없다면 Sort Merge Join이나 Hash Join과 같은 다른 방식이 더 효율적일 수 있습니다.

랜덤 액세스는 레코드 위치와 관계없이 필요한 레코드에 직접 접근하는 방식으로, 디스크 I/O 비용이 높습니다.

<br/>

**2) 소규모 데이터에 적합합니다.**

인덱스가 잘 구성되어 있더라도 데이터가 매우 크면 많은 랜덤 액세스가 발생합니다.

이로 인해 대량 데이터 처리에는 효율성이 떨어집니다.

**Driving 테이블**의 크기가 커질수록 성능이 저하됩니다.

<br/>

**3) OLTP 시스템에 적합합니다.**

작은 데이터 집합을 빠르게 처리하므로 실시간 트랜잭션(OLTP) 환경에 유리합니다.

반면 데이터 양이 큰 OLAP 환경에서는 Sort Merge Join이나 Hash Join이 더 적합합니다.

<br/>

## 정렬 병합 조인

정렬 병합 조인은 두 입력을 각각 읽고, 조인 키로 정렬한 다음, 정렬된 두 흐름을 한 번씩 훑으면서 같은 키를 만날 때마다 결합하는 방식입니다.

이 방식은 조회 범위가 크거나 결과가 많은 경우에 유리합니다.

인덱스가 없거나 범위 비교(<, >, <=, >=)가 조인 조건일 때 주로 선택되며, 정렬이 완료되면 병합 단계는 선형 스캔으로 효율적으로 진행됩니다.

<br/>

### NL 조인의 단점 보완

이 방식은 중첩 루프 조인의 약점을 보완하기 위해 널리 사용됩니다.

중첩 루프는 후행 테이블을 반복적으로 임의 접근하기 때문에 대량 데이터에서 효율성이 크게 떨어집니다.

반면 정렬 병합 조인은 두 테이블을 한 번에 읽고 메모리에서 정렬한 뒤 순차적으로 비교합니다.

이 방식은 랜덤 액세스를 줄이고 순차 스캔 위주로 처리하므로 대용량 데이터에서도 안정적인 처리량을 제공합니다.

<br/>

### 동등 조건의 중요성

정렬 병합 조인에서는 동등 조건이 기본입니다.

같은 값을 맞춰 붙이는 작업에 정렬 순서가 직접 도움이 되기 때문입니다.

부등호 조건을 사용하면 정렬의 이점을 살리기 어렵고 성능이 저하될 수 있습니다.

다만 전외부 조인처럼 전체 행을 보존해야 하는 특수한 경우에는 동등 조건이 없어도 계획이 수립되기도 합니다.

<br/>

### 중복 데이터의 영향

중복 값이 많은 입력은 추가 비용을 유발합니다.

데이터베이스 엔진이 중복 키를 처리하기 위해 더 많은 메모리와 임시 영역을 사용하면서 부하가 증가할 수 있습니다.

가능하면 유니크 인덱스로 중복을 줄이거나, 미리 그룹화하여 레코드 수를 줄여 병합 부담을 낮추는 것이 좋습니다.

<br/>

### 정렬 병합 조인 활용 시기

- 조인 키에 인덱스가 전혀 없을 때,
- 대용량 자료를 조인할 때,
- 조인 조건이 범위 비교일 때,
- 인덱스 기반 랜덤 액세스 오버헤드가 클 때 효과적입니다.

<br/>

### 동작 단계

1. 두 테이블을 **독립적으로 먼저 읽음** →
2. 읽힌 각 결과를 **조인 키로 정렬** →
3. 정렬이 끝나면 **정렬된 두 흐름을 한 번에 스캔하며 병합**

<br/>

### 성능 최적화 포인트

- **접근 속도 개선**: 두 테이블을 처음 읽는 단계(풀스캔 vs 인덱스 스캔)를 최적화합니다.
- **정렬 비용 절감**: 이미 정렬된 입력(인덱스 정렬 등)을 활용하면 유리합니다.
- **양쪽 정렬의 속도 균형**: 한쪽 정렬이 완료되어야 병합이 시작되므로, 병목을 줄이도록 균형을 맞춥니다.
- **정렬 메모리(SORT 영역) 확보**: 메모리가 부족하면 임시 테이블스페이스로 스필되어 성능 지연이 커질 수 있습니다.

<br/>

## 해시 조인

해시 조인은 두 테이블 중 하나를 해시 테이블로 변환하여, 조인 키 값을 해시 알고리즘으로 비교해 매치되는 결과를 얻는 방식입니다.

이는 비용 기반 옵티마이저를 사용할 때만 적용할 수 있으며, '=' 조건의 조인에서만 사용 가능합니다. 주로 대용량 데이터 조인에 효과적입니다.

<br/>

### **해시 조인의 사용처**

**1.** 조인 컬럼에 적절한 인덱스가 없어 중첩 루프 조인이 비효율적일 때

**2.** 조인 접근량이 많아 랜덤 액세스 부하가 심해 중첩 루프 조인이 비효율적일 때

**3.** 정렬 병합 조인을 적용하기에는 테이블이 너무 커서 정렬 부하가 심할 때

**4.** 실행 빈도는 낮지만 쿼리 수행 시간이 오래 걸리는 대용량 테이블을 조인할 때

<br/>

### **해시 조인의 동작 방식**

**1.** 두 집합 중 작은 쪽(Build Input)을 읽어 해시 영역에 해시 테이블을 생성합니다. (해시 함수가 반환한 버킷 주소로 이동하여 해시 체인에 엔트리를 연결)

**2.** 큰 집합(Probe Input)을 읽어 해시 테이블을 탐색하며 조인을 수행합니다.

**3.** 해시 함수에서 반환받은 버킷 주소로 이동해 해시 체인을 스캔하며 데이터를 찾습니다.

<br/>

### **해시 조인의 성능 개선 포인트**

- **해시 테이블 생성 과정 효율화**

해시 조인은 해시 테이블을 생성하는 비용이 수반되므로, 이 과정을 효율화하는 것이 성능 개선의 핵심입니다.

따라서 해시 테이블로 만들 Build Input이 해시 영역에 완전히 담길 정도로 충분히 작아야 하며, Build Input의 해시 키 컬럼에 중복값이 적어야 효율적인 동작을 기대할 수 있습니다.

- **CPU 성능 향상**

해시 버킷이 조인 집합에 구성되어 해시 함수 결과를 저장할 때, HASH_AREA_SIZE에 지정된 메모리가 할당됩니다.

이 과정은 많은 메모리와 CPU 자원을 소모합니다.

CPU 자원이 충분하면 다른 조인 방식보다 효율이 좋지만, 자원이 부족하면 오히려 성능이 저하될 수 있습니다.

따라서 CPU 성능 향상은 해시 조인의 성능 개선으로 직결됩니다.

- **충분한 PGA 메모리 확보**

해시 영역은 PGA 메모리에 할당되는데, Build Input이 HASH_AREA_SIZE를 초과하면 가장 큰 해시 버킷부터 임시 테이블스페이스로 이동합니다.

디스크로 이동한 해시 버킷에 변경이 발생할 때마다 디스크 I/O가 일어나 성능이 크게 저하됩니다.

<br/>
<br/>

> 참고
>
> - https://coding-factory.tistory.com/756
> - https://itpro.tistory.com/198
> - https://ryean.tistory.com/73
> - https://coding-factory.tistory.com/757
> - https://coding-factory.tistory.com/758
