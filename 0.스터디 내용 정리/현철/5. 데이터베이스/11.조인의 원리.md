# 조인의 원리

## 중첩 루프 조인 (Nested Loop Join, NLJ)
### 동작 원리
가장 직관적인 방법.
외부 테이블(outer)의 각 행에 대해 내부 테이블(inner)을 탐색해 조인 조건을 만족하는 행을 찾음.
내부 탐색은 전체 스캔일 수도 있고(단순 NLJ), 인덱스를 이용해 빠르게 찾을 수도 있음(인덱스 네스티드 루프, Index NLJ).
블록 단위(버퍼 단위)로 읽어 블록-중첩루프(Block Nested Loop)를 사용하면 I/O 성능을 개선할 수 있음

### 의사코드
```java
for each row r in OUTER:
    for each row s in INNER:
        if match(r,s): emit combined(r,s)
```

### 복잡도
- 시간: O(|OUTER| * |INNER|) (최악의 경우)
- 인덱스가 있으면 내부 탐색이 O(log N) 혹은 O(1) 수준으로 줄어 실질 비용 감소
- 공간: 추가 메모리 거의 없음 (버퍼 정도)

### 언제 선택되나?
- 한 쪽 테이블(또는 서브쿼리 결과)이 매우 작은 경우
- 반드시 인덱스로 내부 탐색이 가능한 경우 (예: OUTER가 작은 드라이빙 테이블, INNER에 적절한 인덱스)
- 메모리가 부족해 해시/정렬을 못 할 때
- 조건이 비등호(non-equi) 비교(예: <, >)일 때도 자연스럽게 동작

### 장단점
- 장점: 구현 단순, 메모리 요구 적음, 인덱스 활용 시 빠름
- 단점: 두 테이블 모두 클 경우 비용 폭증(카티션 곱 위험). 인덱스 없으면 비효율.

## 정렬 병합 조인 (Sort-Merge Join, SMJ)
### 동작 원리
두 입력을 조인 키 기준으로 정렬한 뒤, 병합(merge) 방식으로 매칭되는 구간을 한 번에 처리.
정렬 후에는 조인 키가 동일한 값들의 구간을 찾아 결합하므로, 큰 범위의 일치(다대다 매칭)에 효율적.
입력이 이미 정렬되어 있거나 인덱스로 정렬된 상태(클러스터드 인덱스 등)라면 정렬 비용을 피할 수 있어 유리

### 의사코드
```java
sort A by key
sort B by key
i = 0; j = 0
while i < A.len and j < B.len:
    if A[i].key < B[j].key: i++
    else if A[i].key > B[j].key: j++
    else:
        emit all combinations of A's current key group and B's current key group
        advance groups
```

### 복잡도
- 정렬 비용: O(|A| log |A| + |B| log |B|) (입력이 정렬되어 있으면 불필요)
- 병합 비용: O(|A| + |B|)
- 공간: 외부 정렬시 디스크 스왑(임시 파일)이 필요할 수 있음(메모리에 따라 달라짐)

### 언제 선택되나?
- 조인 키에 대해 정렬된 입력이 이미 존재할 때(예: 인덱스로 정렬 확보)
- 대량 데이터에서 대규모 일치 그룹(many-to-many)을 효율적으로 처리할 때
- 해시 조인이 비효율적(메모리 부족, 비동등 조건이 복잡한 경우)일 때
- 조인 조건이 등호(equi)뿐 아니라 범위 기반(>=, <=) 병합에도 사용 가능(단 일부 DB 구현은 등호 기반 최적화)

### 장단점
- 장점: 정렬된 입력이 있으면 매우 효율적, I/O가 선형적이라 예측 가능, 대규모 매칭에 안정적
- 단점: 정렬 비용(특히 디스크 스왑)이 크면 비싸다. 랜덤 접근보다 스트리밍 워크로드에 좋음.

## 해시 조인 (Hash Join)
### 동작 원리
일반적으로 동등 조인(equi-join)에 특화된 알고리즘.
작은 쪽(보통 inner build input)을 메모리에서 해시 테이블로 구성(build phase)하고, 큰 쪽(stream input)을 순회하며 해시로 매칭(probe phase).
메모리에 다 안 들어가면 파티셔닝을 이용한 외부 해시 조인(Grace Hash Join)으로 여러 파티션으로 나누고 디스크를 사용해 처리

### 의사코드 (단순)
```java
build_table = hash_table()
for each row r in BUILD_INPUT:  // BUILD_INPUT는 더 작은 테이블
    build_table.insert(r.key, r)
for each row s in PROBE_INPUT:
    for each r in build_table[s.key]:
        emit combined(r,s)
```
### 복잡도
- 평균 시간: O(|A| + |B|) (해시 성능 가정)
- 공간: O(|BUILD_INPUT|) 주요 메모리 사용
- 파티셔닝 시 디스크 I/O 증가(메모리 부족시)
### 언제 선택되나?
- 등치 조인(equi-join) 이고, 메모리에서 작은 테이블을 올릴 수 있을 때 가장 빠름
- 입력이 정렬되어 있지 않아도 됨(정렬 비용 없음)
- 대용량 데이터에 대해도 파티셔닝으로 처리 가능(Grace Hash Join)

### 장단점
- 장점: 등치 조인에서 매우 빠름(선형 시간), 정렬 불필요, 메모리 허용 시 효율적
- 단점: 비등호 조건에는 적용 불가(혹은 비효율), 메모리 제약 시 파티셔닝/디스크 비용 발생, 해시 충돌/해시 품질 영향

## 정리
| 알고리즘           |                      최적 상황 |           복잡도(시간) |              메모리 | 장점                  | 단점              |
| -------------- | -------------------------: | ----------------: | ---------------: | ------------------- | --------------- |
| 중첩 루프 조인 (NLJ) |       작은 드라이빙 테이블 / 인덱스 존재 | O(N*M) (인덱스 있음 ↓) |               낮음 | 단순 · 인덱스 활용 가능      | 큰 테이블에 비효율      |
| 정렬 병합 조인 (SMJ) |      입력이 정렬되어 있거나 대규모 일치그룹 |    정렬 비용 + O(N+M) | 중간~ (외부정렬 시 디스크) | 스트리밍 처리 · 정렬된 입력 활용 | 정렬 비용(디스크 스왑)   |
| 해시 조인 (HJ)     | 등치 조인 · 작은 빌드 테이블 · 메모리 충분 |       O(N+M) (평균) |       높음(빌드 테이블) | 등치 조인에 매우 빠름        | 메모리 부족시 파티셔닝 비용 |
