# 인증
로그인, 토큰, 세션, 쿠키, OAuth, JWT 등 요청을 보낸 사람이 정말 그 사용자가 맞는지 증명하는 과정을 인증이라 한다.

## 인증 vs 인가
| 개념                      | 의미                      | 예시                        |
| ----------------------- | ----------------------- | ------------------------- |
| **인증 (Authentication)** | 사용자가 누구인지 확인            | “이 사용자는 홍길동이다.”           |
| **인가 (Authorization)**  | 인증된 사용자가 무엇을 할 수 있는지 결정 | “홍길동은 관리자 페이지 접근 권한이 있다.” |

# 인증 방식

## 세션 기반 인증
가장 전통적인 웹 인증 방식. 로그인 성공 시 서버가 사용자 정보를 세션 저장소에 보관하고, 클라이언트에게는 세션 ID를 쿠키로 전달한다.

```text
Set-Cookie: JSESSIONID=abc123
```

### 장점
- 서버에서 인증 상태를 완전히 관리 가능
- 세션 만료, 로그아웃 처리가 쉬움

### 단점
- 서버가 세션 상태를 유지해야 하므로 확장성 떨어짐 (서버가 여러 대면 세션 공유 필요 — Redis, Sticky Session 등)
- 모바일/SPA 환경에서는 쿠키 기반 인증이 불편할 수 있음

## 토큰 기반 인증 (Token-based Authentication)
서버가 세션 대신 JWT(JSON Web Token) 같은 토큰을 발급하는 방식. 토큰에는 사용자의 인증 정보와 서명이 포함되어 있고, 서버는 토큰을 검증만 하면 된다.

```text
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

### 장점
- 서버가 인증 상태를 저장하지 않아도 됨 (Stateless)
- 확장성, 부하 분산에 유리
- 모바일/SPA 환경에 적합

### 단점
- 토큰 탈취 시 만료 전까지 무효화 불가
- 로그아웃 처리 복잡 (블랙리스트 필요)
- 토큰 길이가 길어 요청 크기 증가

## OAuth 2.0 — 제3자 인증(Authorization Delegation)
OAuth는 “인증”이라기보다는 “권한 위임” 프로토콜. 즉, 사용자의 자격 증명을 직접 노출하지 않고 제3자 앱이 사용자의 데이터를 접근할 수 있도록 허용한다.

ex)
“구글 계정으로 로그인”
→ 실제로는 구글이 내 신원을 대신 인증해주는 구조

### 장점
- 비밀번호를 제3자 앱에 직접 넘기지 않아도 됨
- API 접근 권한을 세분화 가능 (scope)

### 단점
- 구현이 복잡
- 인증 자체보다는 권한 위임이 목적 (로그인만 필요한 경우엔 적합하지 않음)

## OpenID Connect (OIDC) — OAuth 2.0 기반 인증 프로토콜
OAuth 2.0을 확장해 “로그인(Authentication)” 기능을 추가한 프로토콜. OAuth의 Access Token 외에 ID Token(JWT) 을 추가해 사용자 정보를 제공한다.

```json
{
  "iss": "https://accounts.google.com",
  "sub": "1234567890",
  "email": "user@gmail.com",
  "name": "홍길동"
}
```

### 장점
- OAuth의 권한 위임 + 사용자 인증까지 가능
- 구글/카카오/네이버 로그인 모두 OIDC 기반

### 단점
- 초기 설정 및 표준 이해 필요
- 자체 구현보다는 외부 인증 서버 활용이 일반적

-> 결과적으로, OAuth + OIDC = 소셜 로그인 구현의 표준 구조
