# CSRF & XSS
## XSS (Cross-Site Scripting): 신뢰받는 웹사이트의 배신
XSS는 공격자가 신뢰받는 웹사이트에 악성 스크립트(주로 JavaScript)를 삽입하는 공격. 다른 사용자가 이 웹사이트에 접속하면, 삽입된 악성 스크립트가 사용자의 브라우저에서 실행된다.

- 쉽게 비유하자면:
  - 신뢰할 수 있는 공용 게시판(웹사이트)이 있다.
  - 공격자(Attacker)가 이 게시판에 "유용한 정보"라는 제목으로 글을 쓰지만, 내용물은 사실 "이 글을 읽는 사람의 지갑을 훔쳐라"라는 악성 쪽지(스크립트)다.
  - 피해자(Victim)가 이 게시판을 방문해 해당 글을 읽는 순간, 쪽지의 명령이 실행되어 지갑(세션 쿠키, 개인정보)을 도둑맞게 된다.

### XSS의 주요 유형
- Stored (저장형) XSS
  - 악성 스크립트가 웹사이트의 데이터베이스에 영구적으로 저장. (예: 게시판 글, 사용자 프로필, 댓글)
  - 사용자가 해당 데이터가 포함된 페이지를 요청할 때마다 스크립트가 실행됩니다.

- Reflected (반사형) XSS
  - 악성 스크립트가 URL 파라미터 등에 포함되어 전송된다.
  - 서버가 이 스크립트를 검증 없이 그대로 "반사"하여 응답 페이지에 포함시킬 때 발생. (예: https://example.com/search?q=<script>alert('hacked')</script>)
  - 공격자는 이 악성 URL을 이메일이나 메시지 등으로 사용자에게 클릭하도록 유도해야 한다.

- DOM-based (DOM 기반) XSS
  - 서버와는 무관하게, 브라우저의 DOM(Document Object Model) 환경에서 발생하는 XSS
  - 클라이언트 측 JavaScript가 URL의 일부(예: #)를 가져와 DOM을 조작할 때, 적절한 검증이 없으면 발생

### XSS 방어 전략
**핵심 원칙: 사용자의 입력을 절대로 신뢰하지 않는다.** 

1. Output Encoding (출력 인코딩): 가장 중요하고 확실한 방어법. 사용자로부터 입력받은 데이터를 HTML에 렌더링할 때, 브라우저가 코드로 해석할 수 없도록 문자를 이스케이프(escape) 처리해야 한다.

```text
< → &\lt;

> → &\gt;

" → &\quot; 
```
대부분의 최신 프레임워크(React, Vue 등)나 템플릿 엔진(Thymeleaf 등)은 이를 자동으로 처리해 줌

2. Content Security Policy (CSP):

브라우저에 "이 사이트에서는 오직 'example.com'에서 온 스크립트만 실행해!"라고 알려주는 HTTP 헤더.
CSP를 설정하면, 인라인 스크립트나 알 수 없는 도메인에서 온 스크립트의 실행을 원천적으로 차단할 수 있다.

### CSRF (Cross-Site Request Forgery): 내 권한을 도용당하다
CSRF는 로그인된 사용자의 브라우저를 속여, 사용자가 의도하지 않은 요청(Request)을 다른 웹사이트에 강제로 전송하게 만드는 공격

- 쉽게 비유하자면:
  - 사용자(Victim)가 A 은행(신뢰하는 사이트)에 로그인한 상태로 브라우저는 A 은행의 "로그인 인증서(세션 쿠키)"를 가지고 있다.
  - 공격자(Attacker)가 "무료 치킨 이벤트!"라는 제목의 이메일을 보낸다.
  - 사용자가 이메일의 링크를 클릭하여 악성 B 사이트(공격자 사이트)에 접속한다.
  - B 사이트에는 보이지 않는 이미지가 숨겨져 있다. <img src="https://a-bank.com/transfer?to=attacker&amount=1000000" width="1" height="1">
  - 사용자의 브라우저는 이 이미지를 로드하기 위해 A 은행에 요청을 보냅니다. 이때, 브라우저는 A 은행의 "로그인 인증서(세션 쿠키)"를 자동으로 첨부한다.
  - A 은행 서버는 정상적인 인증서를 확인하고, 사용자가 100만 원을 송금하라는 요청을 보낸 것으로 착각하여 이를 승인합니다. 사용자는 이 사실을 전혀 모릅니다.

### CSRF 공격의 핵심 조건
1. 사용자가 공격 대상 사이트에 로그인된 상태여야 한다.
2. 공격 대상 사이트가 쿠키를 사용한 인증 방식에 의존해야 한다.
3. 공격 대상 사이트에 예측 불가능한 파라미터가 없어야 한다.

### CSRF 방어 전략
**핵심 원칙: 이 요청이 정말 사용자의 의도에서 비롯된 것인지 확인한다.**

- Anti-CSRF Token
  1. 서버는 사용자에게 폼(form)을 제공할 때, 예측 불가능한 임의의 토큰(Token)을 몰래 숨겨서 보낸다.
  2. 사용자가 폼을 제출(submit)할 때, 이 토큰을 함께 전송해야 한다.
  3. 서버는 요청이 들어오면 세션에 저장된 토큰과 요청으로 들어온 토큰이 일치하는지 검사한다.
  4. 공격자는 이 토큰 값을 알 수 없으므로, 위조된 요청은 실패하게 된다.

Java/Spring 에서는 Spring Security에서 활성화할 수 있다. 

- SameSite Cookie Attribute:
  1. 최근 브라우저에서 지원하는 강력한 방어 기능입니다. 쿠키에 SameSite 속성을 설정한다.
  2. SameSite=Strict: 쿠키가 오직 동일한 사이트에서만 전송된다. (CSRF 완벽 방어)
  3. SameSite=Lax: 일부 탐색(예: 링크 클릭)에서는 허용되지만, <img>, <form> POST 등에서는 전송되지 않는다. (대부분의 CSRF 방어)

- Referer / Origin 헤더 검증:
  - 요청이 어디서(어떤 도메인에서) 시작되었는지 Referer 또는 Origin 헤더를 검사하여, 자사 도메인이 아닐 경우 요청을 차단한다.